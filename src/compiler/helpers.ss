;;; helpers.ss
;;; Copyright (c) 2000-2009 R. Kent Dybvig, Andy Keep, Oscar Waddell, Daniel P. Friedman
;;;
;;; In this file:
;;;
;;;   (define-who id defn ... expr) is a syntactic form that defines id
;;;   to be the value of (let () defn ... expr) and, within the let,
;;;   defines the variable who to be 'id.
;;;
;;;   (sra x n) shifts x right by n bits
;;;
;;;   (stack-size) returns the current stack size in 8-byte words
;;;   (stack-size n) sets the stack size to n
;;;
;;;   (heap-size) returns the current heap size in 8-byte words
;;;   (heap-size n) sets the heap size to n
;;;
;;;   (mref reg reg/offset) references the stack or heap memory at
;;;   effective address reg + reg/offset
;;;
;;;   (mset! reg reg/offset x) sets the stack or heap memory at
;;;   effective address reg + reg/offset to x
;;;
;;;   (int32? x) returns true iff x is a 32-bit exact integer
;;;
;;;   (int64? x) returns true iff x is a 64-bit exact integer
;;;
;;;   (uint6? x) returns true iff x is an unsigned 6-bit exact integer
;;;
;;;   (register? x) returns true iff x is a register
;;;
;;;   rax, rcx, rdx, rbx, rbp, rsi, rdi, r8, r9, r10, r11, r12,
;;;   r13, r14, r15 are all defined and set to zero
;;;
;;;   (max-frame-var) returns the current max frame var set up by the system.
;;;   (max-frame-var n) sets the max frame var to n
;;;   
;;;   fv0, fv1, ..., fvN, where N is (max-frame-var), are all defined
;;;   to refer to the proper frame location within the stack, based
;;;   at rbp, e.g., a reference to fv3 is a reference to the stack
;;;   at location ebp + 24.  The offset is 24 rather than 3 since
;;;   each word is 8-bytes.
;;;
;;;   (frame-var? x) returns true iff x is a frame-var in the range
;;;
;;;   (frame-var->index fv) returns the frame variable's index, e.g.,
;;;   the call (frame-var->index 'fv3) returns 3.
;;;
;;;   fv0, fv1, ..., fvN, where N is (max-frame-var)
;;;
;;;   (label? x) returns true iff x is a label
;;;
;;;   (extract-root name) extracts the root of name, i.e., the part
;;;   before the last dollar sign ($) or period (.).
;;;
;;;   (extract-suffix name) extracts the suffix of name, i.e., the part
;;;   after the last dollar sign ($) or period (.).
;;;
;;;   (make-disp-opnd reg offset) returns a disp-opnd record, used to
;;;   represent a displacement-mode operand
;;;
;;;   (disp-opnd? x) returns true iff x is a disp-opnd
;;;
;;;   (disp-opnd-reg disp-opnd) returns the disp-opnd's register
;;;
;;;   (disp-opnd-offset disp-opnd) returns the disp-opnd's offset
;;;
;;;   (make-index-opnd reg offset) returns an index-opnd record, used to
;;;   represent a index-mode operand
;;;
;;;   (index-opnd? x) returns true iff x is a index-opnd
;;;
;;;   (index-opnd-breg index-opnd) returns the index-opnd's base register
;;;
;;;   (index-opnd-ireg index-opnd) returns the index-opnd's index register
;;;
;;;   (label->x86-64-label label) returns a string of the form Ln, where
;;;   n is label's suffix.  used by emit.
;;;
;;;   (rand->x86-64-arg operand) returns a string representing the
;;;   operand, with integers prefixed by $, registers prefixed by
;;;   %, labels converted to rip-relative operands, disp-opnds
;;;   converted to displacement-mode syntax, and index-opnds converted
;;;   to index-mode syntax.  used by emit.
;;;
;;;   (emit-label label) emits label on a line by itself, followed
;;;   by a colon.
;;;
;;;   (emit opcode opnd ...) emits the instruction described by
;;;   opcode and opnd ....  The operands are automatically formatted
;;;   with the help of rand->x86-64-arg.  Use for everything except
;;;   jump instructions.
;;;
;;;   (emit-jump opcode opnd) emits a jump instruction, using the
;;;   peculiar syntax required for jumps.
;;;
;;;   (emit-program code code ...) emits the boilerplate code with
;;;   the code generated by code code ... embedded within it.
;;;
;;;   (make-begin expr*) is flattens begin expressions in expr* and
;;;   tacks the symbol begin on the front of the list, except if the
;;;   list has one element, in which case it returns the element.
;;;   expr* should be nonempty.  E.g., (make-begin '(e1)) => e1 and
;;;   (make-begin '(e1 (begin (begin e2 e3) e4) e5)) =>
;;;   (begin e1 e2 e3 e4 e5).
;;;
;;; This file also sets up record writers for disp-opnd and index-opnd
;;; records and redefine's match's equality check to handle disp-opnds
;;; and index-opnds
(library (compiler helpers)
  (export register? label? frame-var? int32? int64? uint64? frame-var->index
	  uvar? primitive? set? set-cons union intersection difference registers
          unique-label extract-suffix extract-root label->x86-64-label unique-name
          constant? datum? procedure+primitive? value-primitive?
	  predicate-primitive? effect-primitive? binary-op? pred-op?
	  index->frame-var)
  (import (chezscheme))

(define (binary-op? op)
  (memq op '(+ - * logand logor sra)))

(define (pred-op? op)
  (memq op '(< <= = > >=)))
  
(define set?
  (lambda (ls)
    (or (null? ls)
        (and (not (memq (car ls) (cdr ls)))
             (set? (cdr ls))))))

(define set-cons
  (lambda (x set)
    (cond
     [(null? set) (list x)]
     [(eq? x (car set)) set]
     [else (cons (car set) (set-cons x (cdr set)))])))

(define union
  (case-lambda
   [(set1 set2)
    (let loop ([set1 set1])
      (cond
       [(null? set1) set2]
       [(memq (car set1) set2) (loop (cdr set1))]
       [else (cons (car set1) (loop (cdr set1)))]))]
   [() '()]
   [(set1 . sets)
    (let loop ([set1 set1] [sets sets])
      (if (null? sets)
          set1
          (loop (union set1 (car sets)) (cdr sets))))]))

(define intersection
  (case-lambda
   [(set1 set2)
    (let loop ([set1 set1])
      (cond
       [(null? set1) '()]
       [(memq (car set1) set2) (cons (car set1) (loop (cdr set1)))]
       [else (loop (cdr set1))]))]
   [(set1 . sets)
    (let loop ([set1 set1] [sets sets])
      (if (null? sets)
          set1
          (loop (intersection set1 (car sets)) (cdr sets))))]))

(define difference
  (lambda (set1 set2)
    (cond
     ((null? set1) '())
     ((memq (car set1) set2) (difference (cdr set1) set2))
     (else (cons (car set1) (difference (cdr set1) set2))))))

(define primitives
  '((+ . 2) (- . 2) (* . 2) (<= . 2) (< . 2) (= . 2)
    (>= . 2) (> . 2) (boolean? . 1) (car . 1) (cdr . 1)
    (cons . 2) (eq? . 2) (fixnum? . 1) (make-vector . 1)
    (null? . 1) (pair? . 1) (procedure? . 1) (set-car! . 2)
    (set-cdr! . 2) (vector? . 1) (vector-length . 1)
    (vector-ref . 2) (vector-set! . 3) (void . 0)
    (box . 1) (box? . 1) (unbox . 1) (set-box! . 2)))

(define primitive?
  (lambda (pr)
    (assq pr primitives)))

(define procedure+primitive?
  (lambda (pr)
    (or (primitive? pr) (memq pr '(make-procedure procedure-code procedure-ref procedure-set!)))))

(define (value-primitive? x)
  (or (memq x '(+ - * car cdr cons make-vector vector-length vector-ref void))
      (memq x '(make-procedure procedure-code procedure-ref))))

(define (predicate-primitive? x)
  (or (memq x '(< <= = >= > boolean? eq? fixnum? null? pair? vector?))
      (memq x '(procedure?))))

(define (effect-primitive? x)
  (or (memq x '(set-car! set-cdr! vector-set!))
      (memq x '(procedure-set!))))

(define fixnum-bits 61)

(define fixnum-range?
  (lambda (n)
    (<= (- (expt 2 (- fixnum-bits 1)))
        n
        (- (expt 2 (- fixnum-bits 1)) 1))))

(define (constant? x)
  (or (memq x '(#t #f ()))
      (and (and (integer? x) (exact? x))
           (or (fixnum-range? x)
               (error "integer ~s is out of fixnum range" x)))))

(define (datum? x)
  (or (constant? x)
      (if (pair? x)
          (and (datum? (car x)) (datum? (cdr x)))
          (and (vector? x) (andmap datum? (vector->list x))))))

(define word-shift 3) ; 64-bit words

(define int32?
  (lambda (x)
    (and (and (integer? x) (exact? x))
         (<= (- (expt 2 31)) x (- (expt 2 31) 1)))))

(define int64?
  (lambda (x)
    (and (and (integer? x) (exact? x))
         (<= (- (expt 2 63)) x (- (expt 2 63) 1)))))

(define uint64?
  (lambda (x)
    (and (and (integer? x) (exact? x)) (<= 0 x 63))))


(define uvar?
  (lambda (x)
    (and (symbol? x)
	 (let* ([s (symbol->string x)] [n (string-length s)])
           (define (s0 i)
             (and (not (fx= i -1))
		  (cond
		   [(char<=? #\0 (string-ref s i) #\9) (s1 (fx- i 1))]
		   [else #f])))
           (define (s1 i)
             (and (not (fx= i -1))
		  (let ([c (string-ref s i)])
		    (cond
                     [(char<=? #\1 (string-ref s i) #\9) (s1 (fx- i 1))]
                     [(char=? c #\.) #t]
                     [(char=? c #\0) (s2 (fx- i 1))]
                     [else #f]))))
           (define (s2 i)
             (and (not (fx= i -1))
		  (let ([c (string-ref s i)])
		    (cond
                     [(char<=? #\1 (string-ref s i) #\9) (s1 (fx- i 1))]
                     [(char=? c #\0) (s2 (fx- i 1))]
                     [else #f]))))
           (s0 (fx- n 1))))))


;;; registers

(define registers '(rax rcx rdx rbx rbp rsi rdi r8 r9 r10 r11 r12 r13 r14 r15))

(define register?
  (lambda (x)
    (memq x registers)))

(define rax 0)
(define rcx 0)
(define rdx 0)
(define rbx 0)
(define rbp 0)
(define rsi 0)
(define rdi 0)
(define r8 0)
(define r9 0)
(define r10 0)
(define r11 0)
(define r12 0)
(define r13 0)
(define r14 0)
(define r15 0)

;;; frame variables
(define max-frame-var
  (make-parameter 100
		  (let ([next 0])
		    (lambda (n)
		      (unless (and (fixnum? n) (fx>= n 0))
			(error 'max-frame-var "invalid max ~s" n))
		      (when (fx>= n next)
			(do ([i next (fx+ i 1)])
			    ((fx>= i n))
			  (let ([fvi (string->symbol (format "fv~s" i))])
			    (putprop fvi 'frame-index i)))
			(set! next n))))))

(define frame-var?
  (lambda (x)
    (and (symbol? x) (getprop x 'frame-index #f) #t)))

(define frame-var->index
  (lambda (fv)
    (getprop fv 'frame-index)))

(define (index->frame-var n)
  (when (> n (max-frame-var))
    (error 'index->frame "index not in range of max-frame-var"
	   `(index ,n) `(max ,(max-frame-var))))
  (string->symbol (format "fv~d" n)))

;;; labels
  (define count 0)
  (define unique-suffix
    (lambda ()
      (set! count (+ count 1))
      (number->string count)))
  (define unique-name-count
    (case-lambda
      [() count]
      [(x)
       (unless (and (integer? x) (exact? x) (>= x 0))
         (error 'unique-name-count "invalid count ~s" count))
       (set! count x)]))

  (define unique-name
    (lambda (sym)
      (string->symbol
        (string-append (extract-root sym) "." (unique-suffix)))))

  (define unique-label
    (lambda (sym)
      (string->symbol
        (string-append
          (extract-root sym)
          "$"
          (let ([suffix (or (extract-suffix sym) (unique-suffix))])
            (substring suffix 0 (string-length suffix)))))))
(define label?
  (lambda (x)
    (and (symbol? x)
	 (let* ([s (symbol->string x)] [n (string-length s)])
           (define (s0 i)
             (and (not (fx= i -1))
		  (cond
		   [(char<=? #\0 (string-ref s i) #\9) (s1 (fx- i 1))]
		   [else #f])))
           (define (s1 i)
             (and (not (fx= i -1))
		  (let ([c (string-ref s i)])
		    (cond
                     [(char<=? #\1 (string-ref s i) #\9) (s1 (fx- i 1))]
                     [(char=? c #\$) #t]
                     [(char=? c #\0) (s2 (fx- i 1))]
                     [else #f]))))
           (define (s2 i)
             (and (not (fx= i -1))
		  (let ([c (string-ref s i)])
		    (cond
                     [(char<=? #\1 (string-ref s i) #\9) (s1 (fx- i 1))]
                     [(char=? c #\0) (s2 (fx- i 1))]
                     [else #f]))))
           (s0 (fx- n 1))))))

(define extract-root
  (lambda (sym)
    (list->string
     (let ([chars (string->list (symbol->string sym))])
       (define (s0 ls)
         (cond
          [(null? ls) chars]
          [(char-numeric? (car ls)) (s1 (cdr ls))]
          [else chars]))
       (define (s1 ls)
         (cond
          [(null? ls) chars]
          [(char-numeric? (car ls)) (s1 (cdr ls))]
          [(memv (car ls) '(#\. #\$)) (reverse (cdr ls))]
          [else chars]))
       (s0 (reverse chars))))))

(define extract-suffix
  (lambda (sym)
    (let ([str (symbol->string sym)])
      (let ([n (string-length str)]
            [m (string-length (extract-root sym))])
        (and (not (= n m))
             (substring str (+ m 1) n))))))

(define label->x86-64-label
  (lambda (lab)
    (format "L~a" (extract-suffix lab))))

;;; operands

(define (disp-opnd? rand)
  (eq? (car rand) 'disp))

(define rand->x86-64-arg
  (lambda (rand)
    (cond
     [(string? rand) rand] ; precooked operand
     [(number? rand)  (format "$~s" rand)]
     [(register? rand)  (format "%~s" rand)]
     [(label? rand) (format "~a(%rip)" (label->x86-64-label rand))]
     [(disp-opnd? rand) (format "~s(%~s)" (caddr rand) (cadr rand))]
     [else (error "invalid instruction argument ~s" rand)])))

;;; emit routines

(define emit-label
  (lambda (label)
    (if (string? label)
        (printf "~a:\n" label)
        (printf "~a:\n" (label->x86-64-label label)))))

(define-syntax emit
  (syntax-rules ()
    [(_ opcode) (printf "    ~a\n" opcode)]
    [(_ opcode rand)
     (printf "    ~a ~a\n" opcode (rand->x86-64-arg rand))]
    [(_ opcode rand1 rand2)
     (printf "    ~a ~a, ~a\n" opcode
       (rand->x86-64-arg rand1)
       (rand->x86-64-arg rand2))]))

(define-syntax emit-jump
  (syntax-rules ()
    [(_ opcode ?target)
     (let ([target ?target])
       (if (label? target)
           (emit opcode (label->x86-64-label target))
           (emit opcode (format "*~a" (rand->x86-64-arg target)))))]))
)
